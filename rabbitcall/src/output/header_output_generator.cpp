#include "pch.h"


void HeaderOutputGenerator::outputEnum(CppClass *clazz, StringBuilder &output) {
	string namespaceName;
	string unqualifiedName;
	cppParseUtil->cppNamespaceParser.separateNamespaceAndName(namespaceName, unqualifiedName, clazz->typeNames.cppType);

	output.appendLine("");
	if (!namespaceName.empty()) {
		output.appendLine(sb() << "namespace " << namespaceName << " {");
		output.changeIndent(+1);
	}

	// Output a forward declaration for the enum in case it is not #included before this file.
	output.appendLine(sb() << "enum" << (clazz->isClassEnum ? " class" : "") << " " << unqualifiedName << " : int;");

	output.appendLine(sb() << unqualifiedName << " parse_" << unqualifiedName << "(const std::string &s);");
	output.appendLine(sb() << "std::string toString_" << unqualifiedName << "(" << unqualifiedName << " v);");
	output.appendLine(sb() << "std::ostream & operator<<(std::ostream &os, const " << unqualifiedName << " &v);");

	if (!namespaceName.empty()) {
		output.changeIndent(-1);
		output.appendLine("}");
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void HeaderOutputGenerator::generateOutput(StringBuilder &output) {
	StopWatch stopWatch = app->createStopWatchForPerformanceMeasurement();

	output.appendLine(sb() << "// " << getAutogeneratedFileComment());
	output.appendLine("#pragma once");

	output.appendLine("");
	if (isMainPartition()) {
		output.appendLine("#include <atomic>");
		output.appendLine("#include <string>");
		output.appendLine("#include <unordered_map>");
		output.appendLine("#if defined (_MSC_VER)");
		output.appendLine("#include <windows.h>");
		output.appendLine("#endif");

		output.appendLine("");
		output.appendLine("// NOLINTNEXTLINE");
		output.appendLine("#define " OUTPUT_FUNC_MACRO_EXC "(_rc_declaration, _rc_call) extern \"C\" RC_EXPORT void _rc_declaration noexcept{try{_rc_call}catch(std::exception &" OUTPUT_EXCEPTION_VAR "){*" OUTPUT_EXCEPTION_PTR " = _rc_createString(std::string(" OUTPUT_EXCEPTION_VAR ".what()));}}");
		output.appendLine("// NOLINTNEXTLINE");
		output.appendLine("#define " OUTPUT_FUNC_MACRO_NOEXC "(_rc_declaration, _rc_call) extern \"C\" RC_EXPORT void _rc_declaration noexcept{_rc_call}");

		// For each callback function, output a struct that holds a reference to a C# GC handle to the callback method, preventing it from being GC'd as long as there are references on the C++ side.
		// The struct can be passed to user C++ functions also as std::function parameters.
		output.appendLine("");
		output.appendLine("// NOLINTNEXTLINE");
		output.appendLine("#define " OUTPUT_CALLBACK_WRAPPER "(_rc_wrapperClass, _rc_ptrTypedef, _rc_callOperator) \\");
		output.changeIndent(+1);
		output.appendLine("struct _rc_wrapperClass {\\");
		output.changeIndent(+1);
		output.appendLine("_rc_ptrTypedef;\\");
		output.appendLine(OUTPUT_CALLBACK_HOLDER "<FunctionPtrType> *cb;\\");
		output.appendLine("explicit _rc_wrapperClass(" OUTPUT_CALLBACK_HOLDER "<FunctionPtrType> *cb) noexcept : cb(cb) {}\\");
		output.appendLine("_rc_wrapperClass(_rc_wrapperClass const &o) noexcept { cb = NULL; *this = o; }\\");
		output.appendLine("_rc_wrapperClass(_rc_wrapperClass &&o) noexcept { cb = NULL; *this = std::move(o); }/* NOLINT */\\");
		output.appendLine("~_rc_wrapperClass() noexcept { if (cb) { cb->releaseRef(); cb = NULL; } }\\");
		output.appendLine("_rc_wrapperClass & operator=(_rc_wrapperClass const &o) noexcept { if (cb) cb->releaseRef(); cb = o.cb; cb->addRef(); return *this; }/* NOLINT */\\");
		output.appendLine("_rc_wrapperClass & operator=(_rc_wrapperClass &&o) noexcept { if (cb) cb->releaseRef(); cb = o.cb; o.cb = NULL; return *this; }/* NOLINT */\\");
		output.appendLine("_rc_callOperator/* NOLINT */\\");
		output.changeIndent(-1);
		output.appendLine("};");
		output.changeIndent(-1);

		output.appendLine("");
		output.appendLine("class RabbitCallType {");
		output.changeIndent(+1);
		output.appendLine("std::string name;");
		output.appendLine("size_t size;");
		output.changeIndent(-1);
		output.appendLine("public:");
		output.changeIndent(+1);
		output.appendLine("RabbitCallType(const std::string &name, size_t size);");
		output.appendLine("size_t getSize();");
		output.appendLine("const std::string & getName();");
		output.changeIndent(-1);
		output.appendLine("};");

		output.appendLine("");
		output.appendLine("namespace RabbitCallInternalNamespace {");
		output.changeIndent(+1);
		{
			output.appendLine("");
			output.appendLine("struct " OUTPUT_PTR_AND_SIZE " {");
			output.changeIndent(+1);
			output.appendLine("void *ptr;");
			output.appendLine("int64_t size;");
			output.changeIndent(-1);
			output.appendLine("};");

			output.appendLine("");
			output.appendLine("void * " OUTPUT_ALLOCATE_MEMORY "(int64_t size);");
			output.appendLine("void " OUTPUT_DEALLOCATE_MEMORY "(void *ptr) noexcept;");
			output.appendLine("void * " OUTPUT_ALLOCATE_TASKMEM "(int64_t size);");
			output.appendLine("void " OUTPUT_DEALLOCATE_TASKMEM "(void *ptr) noexcept;");

			output.appendLine("");
			output.appendLine("template<typename T>");
			output.appendLine(OUTPUT_PTR_AND_SIZE " _rc_createString(const T &s) {");
			output.changeIndent(+1);
			output.appendLine("int64_t charSize = sizeof(s[0]);");
			output.appendLine("int64_t dataSize = (s.size() + 1) * charSize;"); // Include null terminator in the string.
			output.appendLine("void *data = " OUTPUT_ALLOCATE_MEMORY "(dataSize);");
			output.appendLine("memcpy(data, s.c_str(), dataSize);");
			output.appendLine("return " OUTPUT_PTR_AND_SIZE "{data, dataSize};");
			output.changeIndent(-1);
			output.appendLine("}");

			output.appendLine("");
			output.appendLine("class RabbitCallEnum {");
			output.changeIndent(+1);
			output.appendLine("std::unordered_map<int64_t, std::string> namesById;");
			output.appendLine("std::unordered_map<std::string, int64_t> idsByName;");
			output.changeIndent(-1);
			output.appendLine("public:");
			output.changeIndent(+1);
			output.appendLine("void setMapping(int64_t id, const std::string &name);");
			output.appendLine("int64_t parse(const std::string &name);");
			output.appendLine("std::string toString(int64_t id);");
			output.changeIndent(-1);
			output.appendLine("};");

			output.appendLine("");
			output.appendLine("struct RabbitCallInternal {");
			output.changeIndent(+1);
			output.appendLine("bool initialized = false;");
			output.appendLine("void(*releaseCallbackCallback)(void *) = NULL;"); // Releases a GC handle to C# callback method when there are no more references to it on C++ side.
			output.appendLine("std::unordered_map<std::string, RabbitCallType *> typesByName;");
			output.appendLine("");
			output.appendLine("RabbitCallType * getTypeByName(const std::string &name);");
			output.changeIndent(-1);
			output.appendLine("};");
			output.appendLine("extern RabbitCallInternal rabbitCallInternal;");

			// A class that holds a GC handle for a C# callback method and maintains a reference count.
			output.appendLine("");
			output.appendLine("template<typename T>");
			output.appendLine("struct " OUTPUT_CALLBACK_HOLDER " {");
			output.changeIndent(+1);
			output.appendLine("T callbackHandler;");
			output.appendLine("void *appCallback;");
			output.appendLine("std::atomic_int refCount;");
			output.appendLine("");
			output.appendLine(OUTPUT_CALLBACK_HOLDER "(T callbackHandler, void *appCallback) : callbackHandler(callbackHandler), appCallback(appCallback), refCount(1) {");
			output.appendLine("}");
			output.appendLine("");
			output.appendLine("void addRef() noexcept {");
			output.changeIndent(+1);
			output.appendLine("refCount.fetch_add(1);");
			output.changeIndent(-1);
			output.appendLine("}");
			output.appendLine("");
			output.appendLine("void releaseRef() noexcept {");
			output.changeIndent(+1);
			output.appendLine("int oldValue = refCount.fetch_add(-1);");
			output.appendLine("if (oldValue <= 1) {");
			output.changeIndent(+1);
			output.appendLine("rabbitCallInternal.releaseCallbackCallback(appCallback);");
			output.appendLine("delete this;");
			output.changeIndent(-1);
			output.appendLine("}");
			output.changeIndent(-1);
			output.appendLine("}");
			output.changeIndent(-1);
			output.appendLine("};");

			output.appendLine("");
			cppProject->forEachPartition([&](CppPartition *p) {
				output.appendLine(sb() << "void initPartition_" << p->getName() << "();");
			});
		}
		output.changeIndent(-1);
		output.appendLine("}");
	}
	else {
		// Include the main partition's header file in other header files, because it contains the common definitions.
		shared_ptr<CppOutputFile> mainHeaderOutputFile = getMainPartition()->getOutputFileByTypeIfExists("h");
		if (!mainHeaderOutputFile) EXC(sb() << "Main partition does not have a header output file: " << getMainPartition()->getName());
		output.appendLine(sb() << "#include \"" << getRelativePathForIncludeDirective(mainHeaderOutputFile->file.toString()) << "\"");
	}

	partition->forEachClass([&](CppClass *clazz) {
		if (clazz->classType == CppClassDeclarationType::ENUM) {
			outputEnum(clazz, output);
		}
	});

	stopWatch.mark("output / generate .h");
}
