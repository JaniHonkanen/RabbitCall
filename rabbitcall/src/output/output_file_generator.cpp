#include "pch.h"


void OutputFileGenerator::init(CppPartition *partition, CppPartition *mainPartition) {
	this->partition = partition;
	this->mainPartition = mainPartition;

	cppProject = partition->getCppProject();
	config = cppProject->getConfig();
	cppLibraryFile = config->cppLibraryFile;

	outputFile = partition->getOutputFileByTypeIfExists(getFileType()).get();

	if (outputFile && !outputFile->file.empty()) {
		outputDir = outputFile->file.path().parent_path();
	}
}

string OutputFileGenerator::getRelativePathForIncludeDirective(const string &file) {
	string result = getRelativePathBetweenAbsolutePaths(file, outputDir.toString());
	boost::replace_all(result, "\\", "/");
	return result;
}

string OutputFileGenerator::getAutogeneratedFileComment() {
	return sb() << "This file was auto-generated by " << cppProject->getConfig()->programName << " - do not modify manually.";
}

CppFuncVar OutputFileGenerator::getFunctionReturnValuePtrType(const CppFuncVar *func) {
	CppFuncVar type = func->getFunctionReturnType();
	type.pointerDepth++;
	type.declarationName = OUTPUT_RETURN_VALUE_PTR;
	return type;
}

string OutputFileGenerator::formatDeclaration(const CppFuncVar &declaration, const string &displayName, Language language, TypePresentation presentation) {
	StringBuilder b;

	TypeMapping *typeMapping = declaration.type;
	int pointerDepthToUse = declaration.pointerDepth;
	bool variableNameAlreadyWritten = false;

	if (language == Language::CPP) {
		if (presentation == TypePresentation::PUBLIC) {
			b << typeMapping->typeNames.cppType;
		}
		else if (presentation == TypePresentation::TRANSFER_PARAMETER) {
			b << typeMapping->cppTransferTypeName;
		}
		else if (presentation == TypePresentation::TRANSFER_RETURN_VALUE) {
			if (typeMapping->isString) {
				b << OUTPUT_PTR_AND_SIZE;
			}
			else {
				b << typeMapping->cppTransferTypeName;
			}
		}
		else if (presentation == TypePresentation::TRANSFER_CALLBACK_PARAMETER) {
			b << typeMapping->cppTransferTypeName;
		}
		else if (presentation == TypePresentation::TRANSFER_CALLBACK_RETURN_VALUE) {
			b << typeMapping->cppTransferTypeName;
		}

		if (presentation != TypePresentation::PUBLIC) {
			if (declaration.isLambdaFunction) {
				variableNameAlreadyWritten = true;
				b << " (*" << displayName << ")(";
				StringJoiner joiner(&b, ",");
				for (auto &param : declaration.functionParameters) {
					joiner.append(formatDeclaration(*param, "", Language::CPP, TypePresentation::TRANSFER_CALLBACK_PARAMETER));
				}

				if (presentation == TypePresentation::TRANSFER_PARAMETER) {
					// Callback handlers take the pointer to the application callback as an extra parameter.
					joiner.append("void *");
				}

				joiner.finish();
				b << ")";
			}
		}
	}
	else if (language == Language::CS) {
		// C++ pointers to pass-by-reference types are wrapped in a struct in C#.
		if (!typeMapping->isPassByValue) {
			pointerDepthToUse = max(0, pointerDepthToUse - 1);
		}

		string type = typeMapping->typeNames.csType;
		if (presentation == TypePresentation::TRANSFER_RETURN_VALUE) {
			if (typeMapping->isString) {
				type = OUTPUT_PTR_AND_SIZE;
			}
		}
		else if (presentation == TypePresentation::TRANSFER_PARAMETER || presentation == TypePresentation::TRANSFER_CALLBACK_PARAMETER) {
			string marshalAttribute = typeMapping->csMarshalAttributeIfUsed;
			if (!marshalAttribute.empty()) {
				b << "[" << marshalAttribute << "] ";
			}
		}
		b << type;
	}
	else {
		throw ParseException(declaration.sourceLocation, sb() << "Unsupported language for formatting declaration: " << language);
	}

	int64_t guaranteedAlignmentForStructPassByValue = 8;
	if (presentation != TypePresentation::PUBLIC && typeMapping->isPassByValue && declaration.pointerDepth == 0 && (int64_t)typeMapping->alignment > guaranteedAlignmentForStructPassByValue) {
		throw ParseException(declaration.sourceLocation, sb() << "Cannot use pass-by-value (or pass-by-reference that is converted to pass-by-value in the interface) for type " << typeMapping->typeNames.cppType << ", because it requires alignment " << typeMapping->alignment << " but C# aligns parameters and return values only by " << guaranteedAlignmentForStructPassByValue
			<< ". You can pass a pointer instead (and make sure it is aligned), or create a wrapper function that accepts an unaligned parameter or return value and invokes the original function (e.g. XMFLOAT4 instead of XMVECTOR).");
	}

	if (pointerDepthToUse > 0) {
		// Add a space between variable type and the pointer asterisks, unless the type name ended with a pointer asterisk
		// (in which case don't add an extra space between the asterisks).
		if (b.buffer.length() > 0 && b.buffer[b.buffer.length() - 1] != '*') b << " ";

		for (int i = 0; i < pointerDepthToUse; i++) {
			b << "*";
		}
	}

	if (!variableNameAlreadyWritten && !displayName.empty()) {
		// Add a space after the type if there are no pointer asterisks.
		if (b.buffer.length() > 0 && b.buffer[b.buffer.length() - 1] != '*') b << " ";

		b << displayName;
	}

	return b;
}

string OutputFileGenerator::formatDeclaration(const CppFuncVar &declaration, Language language, TypePresentation presentation) {
	return formatDeclaration(declaration, declaration.declarationName, language, presentation);
}

bool OutputFileGenerator::outputComment(CppComment *comment, StringBuilder &output) {
	bool hasComments = false;
	if (comment) {
		for (const string &commentLine : comment->lines) {
			output.appendLine(commentLine);
			hasComments = true;
		}
	}
	return hasComments;
}

bool OutputFileGenerator::updateGeneratedUtf8FileIfModified(const Path &path, const void *data, int64_t length, bool addByteOrderMark, bool shouldUseCrLfLineBreaks, bool dryRun) {
	StopWatch stopWatch = app->createStopWatchForPerformanceMeasurement();
	ByteBuffer newData;
	if (addByteOrderMark) {
		newData.put<uint8_t>(0xEF);
		newData.put<uint8_t>(0xBB);
		newData.put<uint8_t>(0xBF);
	}
	convertLineBreaks(&newData, data, length, shouldUseCrLfLineBreaks);
	stopWatch.mark("output / update file / convert line breaks");

	if (exists(path.path())) {
		ByteBuffer oldData;
		loadBinaryFile(&oldData, path);
		stopWatch.mark("output / update file / load old file");

		if (oldData.getPosition() == newData.getPosition() && memcmp(oldData.getBuffer(), newData.getBuffer(), oldData.getPosition()) == 0) {
			LOG_DEBUG(sb() << "File up-to-date: " << path);
			return false;
		}
	}

	if (dryRun) {
		LOG_ERROR(sb() << "Would update auto-generated file if dry-run mode was not enabled: " << path);
	}
	else {
		saveBinaryFile(path, newData.getBuffer(), newData.getPosition());
		stopWatch.mark("output / update file / save");
		LOG_INFO(sb() << "Saved auto-generated file: " << path);
	}

	return true;
}




