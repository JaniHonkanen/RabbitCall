<?xml version="1.0" encoding="utf-8"?>
<project>
	<!-- Detail level of log messages: off, error, info or debug. -->
	<logLevel>info</logLevel>

	<!-- Log file path. -->
	<logFile>rabbitcall_log.txt</logFile>

	<!-- Prefix added to every log message to better identify them in the IDE. -->
	<logMessagePrefix>RabbitCall</logMessagePrefix>
	
	<!--
	Name of the .dll/.so file generated by the C++ project.
	You can omit file extension when using .Net Core and .Net Framework regardless of OS, but not when using Mono.
	-->
	<cppLibraryFile>cpp_prj</cppLibraryFile>

	<!--
	Directories for files generated by the tool. Add them as source files in your projects.
	You can set the "bom" attribute to "true" to indicate that a UTF-8 byte-order-mark should be written at the
	beginning of an output file. This may help some compilers identify the file encoding if you use non-ASCII
	characters, but may confuse e.g. a HLSL compiler.
	-->
	<outputDir type="cpp" bom="false">cpp_prj/src/rabbitcall</outputDir>
	<outputDir type="h" bom="false">cpp_prj/src/rabbitcall</outputDir>
	<outputDir type="cs" bom="false">csharp_prj/src/rabbitcall</outputDir>
	<outputDir type="hlsl" bom="false">csharp_prj/src/rabbitcall</outputDir>
	<outputDir type="glsl" bom="false">csharp_prj/src/rabbitcall</outputDir>

	<!--
	If the source code is large (>100MB), it can be split to multiple partitions to reduce compile times.
	For each partition, a separate set of output files will be generated. The main benefit is that the
	C++ compiler (which is much slower than this tool) only has to recompile those generated files that
	have changed and files depending on them.
	-->
	<partitions>
		<!-- This creates a single partition scanning all header files under the specified directory recursively. -->
		<!--
 		<partition name="main">
			<cppSourceFiles dir="cpp_prj/src"/>
		</partition>
		-->

		<!--
		The generated files of the first partition will contain common definitions used by all partitions. If you have
		multiple partitions and want to avoid recompiling all when something in the first partition is changed, you can
		use an empty partition as the first partition. When you add/remove/rename partitions, remember to remove old
		generated files from the output directory and add/remove the files in the compiler's file list.
		-->
		<partition name="main">
		</partition>
		<partition name="partition1">
			<!-- Path to the C++ source root directory (relative to the this configuration file's directory). -->
			<cppSourceFiles dir="cpp_prj/src">
				<!--
				Include/exclude directories and files. Each directive in the list below is applied after the ones
				preceding it, e.g. you can exclude a subdirectory except include a particular subdirectory inside it.
				A directive applies recursively to all subdirectories and files. In the beginning, everything under
				the base directory is included, unless the first directive is an include, in which case only the
				specified directory is included.
				-->
				<exclude path="file_set_test"/>
				<include path="file_set_test/vehicle"/>
				<exclude path="file_set_test/vehicle/car"/>
			</cppSourceFiles>
		</partition>
		<partition name="partition2">
			<cppSourceFiles dir="cpp_prj/src">
				<include path="file_set_test/house"/>
			</cppSourceFiles>
		</partition>
	</partitions>

	<!--
	If 'true', all #include directives in those header files that contain exportable classes/functions will be copied
	to the generated .cpp file, so that if exported function declarations refer to types that are defined in some 3rd
	party headers not parsed by the tool, they will be included when compiling the generated .cpp file. Generally this
	setting can be always on if there are "#pragma once" checks in all headers, but may be unnecessary if all types get
	included via a precompiled header.
	-->
	<includeSourceHeadersInGeneratedCpp>true</includeSourceHeadersInGeneratedCpp>
	
	<!--
	The keyword to add to the beginning of all classes/structs/functions/enums to export from C++.
	-->
	<exportKeyword>FXP</exportKeyword>

	<!--
	Prefix and suffix to add to pointers in C# that point to exported C++ objects. Applies only to pass-by-reference
	classes and not pass-by-value structs or enums. Intended to make it clear in C# that these are pointers to
	C++ objects and not local C# objects.
	-->
	<csClassNamePrefix>N</csClassNamePrefix>
	<csClassNameSuffix></csClassNameSuffix>
	
	<!--
	C# namespace for all generated declarations. Can have multiple parts, e.g. "OuterNamespace::InnerNamespace".
	-->
	<csNamespace>CsNamespace</csNamespace>

	<!--
	C# class name that will have static functions for all exported global C++ functions. A different C# class
	will be generated for each C++ namespace.
	-->
	<csGlobalFunctionContainerClass>NGlobal</csGlobalFunctionContainerClass>

	<maxThreads>1</maxThreads>
	
	<!--
	These code lines will be added to the beginning of the generated .cpp file.
	If you use a precompiled header, put the #include here.
	-->
	<generatedCppFilePrologue>
<![CDATA[
#include "pch.h"
]]>
	</generatedCppFilePrologue>

	<!--
	Mappings between C++, C# and HLSL types. Types that are exported with the FXP keyword from your
	C++ application don't need to be listed here.
	-->
	<typeMappings>
		<!--
		Treat all C++ std::string objects as UTF-8 (ASCII chars 0..127 will be the same as with
		any 8-bit Latin encoding).
		-->
		<type cpp="std::string" cs="string" marshal="string.utf8" charType="char"/>
		<type cpp="char" cs="byte" size="1" alignment="1"/>

		<!--
		std::u8string requires C++20, but you can also use UTF-8 for std::string as a convention.
		-->
		<!--
		<type cpp="std::u8string" cs="string" marshal="string.utf8" charType="char"/>
		<type cpp="char8_t" cs="byte" size="1" alignment="1"/>
		-->

		<type cpp="std::u16string" cs="string" marshal="string.utf16" charType="char16_t"/>
		<type cpp="char16_t" cs="char" size="2" alignment="2"/>

		<!--
		wstring is supported, but it is not portable, because it uses UTF-16 on Windows and UTF-32 on Linux.
		It is preferable to use UTF-8 in C++ and only convert to wstring when invoking Windows API functions.
		-->
		<!--
		<type cpp="std::wstring" cs="string" marshal="string.utf16" charType="wchar_t"/>
		<type cpp="wchar_t" cs="char" size="2" alignment="2"/>
		-->

		<type cpp="void"               cs="void"/>
		<type cpp="bool"               cs="bool"                               size="1" alignment="1"/>
		<!--<type cpp="byte"           cs="byte"                               size="1" alignment="1"/>-->
		<type cpp="signed char"        cs="sbyte"                              size="1" alignment="1"/>
		<type cpp="unsigned char"      cs="byte"                               size="1" alignment="1"/>
		<type cpp="short"              cs="short"                              size="2" alignment="2"/>
		<type cpp="signed short"       cs="short"                              size="2" alignment="2"/>
		<type cpp="unsigned short"     cs="ushort"                             size="2" alignment="2"/>
		<type cpp="int"                cs="int"    hlsl="int"  glsl="int"      size="4" alignment="4"/>
		<type cpp="signed int"         cs="int"    hlsl="int"  glsl="int"      size="4" alignment="4"/>
		<type cpp="unsigned int"       cs="uint"   hlsl="uint" glsl="uint"     size="4" alignment="4"/>
		<type cpp="long long"          cs="long"                               size="8" alignment="8"/>
		<type cpp="signed long long"   cs="long"                               size="8" alignment="8"/>
		<type cpp="unsigned long long" cs="ulong"                              size="8" alignment="8"/>
		<type cpp="int8_t"             cs="sbyte"                              size="1" alignment="1"/>
		<type cpp="uint8_t"            cs="byte"                               size="1" alignment="1"/>
		<type cpp="int16_t"            cs="short"                              size="2" alignment="2"/>
		<type cpp="uint16_t"           cs="ushort"                             size="2" alignment="2"/>
		<type cpp="int32_t"            cs="int"                                size="4" alignment="4"/>
		<type cpp="uint32_t"           cs="uint"                               size="4" alignment="4"/>
		<type cpp="int64_t"            cs="long"                               size="8" alignment="8"/>
		<type cpp="uint64_t"           cs="ulong"                              size="8" alignment="8"/>
		<type cpp="float"              cs="float"  hlsl="float"  glsl="float"  size="4" alignment="4"/>
		<type cpp="double"             cs="double" hlsl="double" glsl="double" size="8" alignment="8"/>
		<type cpp="size_t"             cs="ulong"                              size="8" alignment="8"/>

		<!-- SSE vector types. -->
		<type cpp="__m128"  cs="System.Numerics.Vector4" hlsl="float4"  glsl="vec4"  size="16" alignment="16"/>
		<type cpp="__m128i" cs="Int4"                    hlsl="int4"    glsl="ivec4" size="16" alignment="16"/>
		<type cpp="__m128d" cs="Double2"                 hlsl="double2" glsl="dvec2" size="16" alignment="16"/>

		<!-- Vector types implemented as custom structs in C++ and mapped to internal C# structs. -->
		<type cpp="float4"   cs="System.Numerics.Vector4"   hlsl="float4" glsl="vec4" size="16" alignment="4"/>
		<type cpp="float3"   cs="System.Numerics.Vector3"   hlsl="float3" glsl="vec3" size="12" alignment="4"/>
		<type cpp="float2"   cs="System.Numerics.Vector2"   hlsl="float2" glsl="vec2" size="8"  alignment="4"/>
		<type cpp="float4x4" cs="System.Numerics.Matrix4x4" hlsl="matrix" glsl="mat4" size="64" alignment="16"/>

		<!-- A struct for which C++ and C# versions are defined manually instead of auto-generating the C# version. -->
		<type cpp="CustomSharedStruct" cs="CustomSharedStruct" size="20" alignment="4"/>

		<!-- Windows types. -->
		<!--
		<type cpp="BYTE"     cs="byte"                                                 size="1"  alignment="1"/>
		<type cpp="WORD"     cs="ushort"                                               size="2"  alignment="2"/>
		<type cpp="DWORD"    cs="uint"                      hlsl="uint"   glsl="uint"  size="4"  alignment="4"/>
		<type cpp="UINT"     cs="uint"                      hlsl="uint"   glsl="uint"  size="4"  alignment="4"/>
		<type cpp="XMFLOAT4" cs="System.Numerics.Vector4"   hlsl="float4" glsl="vec4"  size="16" alignment="4"/>
		<type cpp="XMFLOAT3" cs="System.Numerics.Vector3"   hlsl="float3" glsl="vec3"  size="12" alignment="4"/>
		<type cpp="XMFLOAT2" cs="System.Numerics.Vector2"   hlsl="float2" glsl="vec2"  size="8"  alignment="4"/>
		<type cpp="XMINT4"   cs="Int4"                      hlsl="int4"   glsl="ivec4" size="16" alignment="4"/>
		<type cpp="XMINT3"   cs="Int3"                      hlsl="int3"   glsl="ivec3" size="12" alignment="4"/>
		<type cpp="XMINT2"   cs="Int2"                      hlsl="int2"   glsl="ivec2" size="8"  alignment="4"/>
		<type cpp="XMVECTOR" cs="System.Numerics.Vector4"   hlsl="float4" glsl="vec4"  size="16" alignment="16"/>
		<type cpp="XMMATRIX" cs="System.Numerics.Matrix4x4" hlsl="matrix" glsl="mat4"  size="64" alignment="16"/>
		-->
	</typeMappings>
</project>
