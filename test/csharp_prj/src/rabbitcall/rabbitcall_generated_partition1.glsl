// This file was auto-generated by RabbitCall - do not modify manually.


// An enum is converted to const variables in HLSL/GLSL.

const int test_VALUE1 = 1;
const int test_VALUE2 = 2;
const int test_VALUE3 = 3;
// This comment should get copied
// to the generated file.
const int test_VALUE4 = 4;

// Struct fields must be aligned in C++ according to the HLSL/GLSL packing rules. E.g. in HLSL, each element crossing a 16-byte boundary must be aligned by 16 bytes.
struct GpuStruct {
	// These two fields fill the first 16 bytes.
	vec2 v1;
	vec2 v2;
	// The next two fields fill the next 16 bytes. If these were declared in reverse order, GLSL would align the
	// 3-component vector to the next 16-byte boundary while HLSL would place it directly after the integer.
	vec3 v3;
	int i3;
	int i4;
	// Use the "alignas" keyword to align the vector the same way in C++ as in HLSL/GLSL. Another option is to add padding fields.
	vec4 v4;
	vec4 array1[2];
};

// An optional prefix can be added to all constant buffer / uniform block fields in case they are seen as global variables in HLSL/GLSL code.
// In GLSL, you can use the instanceName attribute to make the fields non-global.
// The constant buffer / uniform block can be (optionally) mapped to a specific HLSL register or a GLSL binding index.
// Variable initializer expressions are allowed, but won't be exported to C# (but you can call a C++ function that invokes a constructor to run the initializers).
layout(std140) uniform GpuConstantBuffer {
	mat4 g_m;
	vec2 g_v1;
	float g_v2;
	// This vector will be aligned automatically.
	vec4 g_v3;
	GpuStruct g_s;
} constants;
